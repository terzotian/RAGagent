import io
import mimetypes
import os
import random
import json
from urllib.parse import unquote

import uvicorn
import markdown as md_lib
import mammoth

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from fastapi import FastAPI, HTTPException, status, Depends, UploadFile, File, Form, Query
from fastapi.responses import StreamingResponse, HTMLResponse, PlainTextResponse, FileResponse
from pydantic import BaseModel, Field
from typing import List, Dict
from datetime import datetime, timezone
from fastapi.responses import StreamingResponse

from backend.model.doc_analysis import split
from backend.model.agent_router import route_stream
from backend.model.rag_indexer import ingest_file
from sqlalchemy import create_engine, Column, String, Text, Integer, TIMESTAMP, func, LargeBinary, text, orm, Index, Enum as SQLEnum
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.dialects.postgresql import JSONB as JSON
from passlib.context import CryptContext
pwd_context = CryptContext(schemes=["pbkdf2_sha256"], deprecated="auto")

from backend.model.ques_assemble import generate_search_query
from backend.model.doc_search import search_documents, load_segments_from_folder
from backend.root_path import PIECES_DIR, locate_path, policy_file, piece_file, piece_dir

# 数据库配置
# MySQL (Old): DATABASE_URL = "mysql+mysqlconnector://root:TTZZ3388@localhost:3306/LURAG"
# PostgreSQL (New):
DATABASE_URL = "postgresql://postgres:TTZZ3388@localhost:5432/LURAG"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = orm.declarative_base()


# 数据库模型
class DBSession(Base):
    __tablename__ = "sessions"
    session_id = Column(String(28), primary_key=True)
    user_id = Column(Integer, nullable=True)
    title = Column(String(255), nullable=True)
    created_at = Column(TIMESTAMP, server_default=func.now())
    last_activity = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())


class DBQuestion(Base):
    __tablename__ = "questions"
    session_id = Column(String(28), primary_key=True)
    question_id = Column(String(28), primary_key=True)
    previous_questions = Column(JSON)
    current_question = Column(Text)
    answer = Column(Text)
    references = Column(JSON)  # 更新字段名
    rating = Column(Integer)
    created_at = Column(TIMESTAMP, server_default=func.now())


class DBFile(Base):
    __tablename__ = "files"
    # 复合主键 (base, file_name)
    base = Column(String(28), primary_key=True, nullable=False, server_default="lingnan",
                  comment="文件来源于哪个知识库")
    file_name = Column(String(255), primary_key=True, nullable=False, comment="文件名称")
    file_description = Column(Text, comment="文件简介")
    file_path = Column(String(512), nullable=False, comment="文件在存储系统里的路径或 URL")
    file_size = Column(String(28), nullable=False, comment="文件大小")
    uploaded_at = Column(
        TIMESTAMP,
        nullable=False,
        server_default=func.now(),
        onupdate=func.current_timestamp(),
        comment="上传/更新文件时间"
    )
    __table_args__ = (
        # 加速按 base 查询
        Index("idx_base", "base"),
    )


class DBUser(Base):
    __tablename__ = "users"
    user_id = Column(Integer, primary_key=True, autoincrement=True)
    account = Column(String(50), unique=True, nullable=False)
    password_hash = Column(String(255), nullable=False)
    nickname = Column(String(50), nullable=False)
    gender = Column(String(10), nullable=False)
    identity = Column(String(20), nullable=False)
    avatar_path = Column(String(255), nullable=True)
    created_at = Column(TIMESTAMP, server_default=func.now())


Base.metadata.create_all(bind=engine)
try:
    with engine.connect() as conn:
        conn.execute(text("ALTER TABLE users ALTER COLUMN user_id ADD GENERATED BY DEFAULT AS IDENTITY"))
        seq_name = conn.execute(text("SELECT pg_get_serial_sequence('users','user_id')")).scalar()
        if seq_name:
            conn.execute(text(f"SELECT setval('{seq_name}', COALESCE((SELECT MAX(user_id) FROM users), 1))"))
        conn.commit()
except Exception:
    pass

app = FastAPI()

# CORS配置
from fastapi.middleware.cors import CORSMiddleware

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)


# 依赖项
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# 数据模型
class QuestionRequest(BaseModel):
    session_id: str = Field(..., min_length=6)
    question_id: str = Field(..., min_length=10)
    previous_questions: List[str] = []
    current_question: str = Field(..., min_length=1)


class QuestionResponse(BaseModel):
    session_id: str
    question_id: str
    answer: str
    references: List[Dict[str, str]]


class FeedbackRequest(BaseModel):
    session_id: str
    question_id: str
    rating: int = Field(..., ge=1, le=10)


class FeedbackResponse(BaseModel):
    session_id: str
    question_id: str


import re
from pydantic import BaseModel, Field, validator

class UserRegister(BaseModel):
    account: str = Field(..., description="Phone number (digits only)")
    password: str = Field(..., description="6-digit password")
    nickname: str = Field(..., description="Nickname (English or Chinese)")
    gender: str
    identity: str

    @validator('account')
    def validate_account(cls, v):
        if not re.match(r'^\d{11}$', v):
            raise ValueError('Account must be an 11-digit phone number')
        return v

    @validator('password')
    def validate_password(cls, v):
        if not re.match(r'^\d{6}$', v):
            raise ValueError('Password must be exactly 6 digits')
        return v

    @validator('nickname')
    def validate_nickname(cls, v):
        if not re.match(r'^[\u4e00-\u9fa5a-zA-Z]+$', v):
            raise ValueError('Nickname must contain only English or Chinese characters')
        return v


class UserLogin(BaseModel):
    account: str
    password: str


class UserUpdate(BaseModel):
    nickname: str = Field(..., description="Nickname")
    gender: str
    identity: str

    @validator('nickname')
    def validate_nickname(cls, v):
        if not re.match(r'^[\u4e00-\u9fa5a-zA-Z]+$', v):
            raise ValueError('Nickname must contain only English or Chinese characters')
        return v

class PasswordUpdate(BaseModel):
    old_password: str
    new_password: str = Field(..., description="6-digit password")

    @validator('new_password')
    def validate_password(cls, v):
        if not re.match(r'^\d{6}$', v):
            raise ValueError('Password must be exactly 6 digits')
        return v

@app.get("/api/v1/users/{user_id}")
async def get_user_profile(user_id: int, db: Session = Depends(get_db)):
    user = db.query(DBUser).filter(DBUser.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    return {
        "user_id": user.user_id,
        "account": user.account,
        "nickname": user.nickname,
        "gender": user.gender,
        "identity": user.identity,
        "avatar_path": user.avatar_path
    }

@app.put("/api/v1/users/{user_id}")
async def update_profile(user_id: int, update_data: UserUpdate, db: Session = Depends(get_db)):
    user = db.query(DBUser).filter(DBUser.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    user.nickname = update_data.nickname
    user.gender = update_data.gender
    user.identity = update_data.identity
    db.commit()
    db.refresh(user)
    return {
        "message": "Profile updated",
        "user": {
            "user_id": user.user_id,
            "account": user.account,
            "nickname": user.nickname,
            "gender": user.gender,
            "identity": user.identity,
            "avatar_path": user.avatar_path
        }
    }

@app.put("/api/v1/users/{user_id}/password")
async def update_password(user_id: int, password_data: PasswordUpdate, db: Session = Depends(get_db)):
    user = db.query(DBUser).filter(DBUser.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    if not pwd_context.verify(password_data.old_password, user.password_hash):
        raise HTTPException(status_code=400, detail="Incorrect old password")

    user.password_hash = pwd_context.hash(password_data.new_password)
    db.commit()
    return {"message": "Password updated successfully"}

@app.post("/api/v1/users/{user_id}/avatar")
async def upload_avatar(user_id: int, file: UploadFile = File(...), db: Session = Depends(get_db)):
    user = db.query(DBUser).filter(DBUser.user_id == user_id).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create avatars directory
    avatars_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "avatars")
    os.makedirs(avatars_dir, exist_ok=True)

    # Save file
    file_ext = os.path.splitext(file.filename)[1]
    filename = f"user_{user_id}_{int(datetime.now().timestamp())}{file_ext}"
    file_path = os.path.join(avatars_dir, filename)

    content = await file.read()
    with open(file_path, "wb") as f:
        f.write(content)

    # Delete old avatar if exists
    if user.avatar_path:
        old_path = os.path.join(avatars_dir, os.path.basename(user.avatar_path))
        if os.path.exists(old_path):
            try:
                os.remove(old_path)
            except:
                pass

    # Store relative path or full URL. Storing relative filename is safer.
    # We will serve it via a static endpoint.
    user.avatar_path = filename
    db.commit()

    return {"message": "Avatar uploaded", "avatar_path": filename}

@app.get("/api/v1/avatars/{filename}")
async def get_avatar(filename: str):
    avatars_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), "avatars")
    file_path = os.path.join(avatars_dir, filename)
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="Avatar not found")
    return FileResponse(file_path)

@app.post("/api/v1/auth/register")
async def register(user: UserRegister, db: Session = Depends(get_db)):
    # Check if user exists
    existing_user = db.query(DBUser).filter(DBUser.account == user.account).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Account already exists")

    hashed_password = pwd_context.hash(user.password)
    new_user = DBUser(
        account=user.account,
        password_hash=hashed_password,
        nickname=user.nickname,
        gender=user.gender,
        identity=user.identity
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return {"message": "User registered successfully", "user_id": new_user.user_id}


@app.post("/api/v1/auth/login")
async def login(user: UserLogin, db: Session = Depends(get_db)):
    db_user = db.query(DBUser).filter(DBUser.account == user.account).first()
    if not db_user or not pwd_context.verify(user.password, db_user.password_hash):
        raise HTTPException(status_code=401, detail="Invalid account or password")

    return {
        "message": "Login successful",
        "user": {
            "user_id": db_user.user_id,
            "account": db_user.account,
            "nickname": db_user.nickname,
            "gender": db_user.gender,
            "identity": db_user.identity,
            "avatar_path": db_user.avatar_path
        }
    }

@app.post("/api/v1/auth/admin_reset_password")
async def admin_reset_password(account: str = Query(...), new_password: str = Query(...), token: str = Query(...), db: Session = Depends(get_db)):
    expected = os.getenv("ADMIN_RESET_TOKEN")
    if not expected or token != expected:
        raise HTTPException(status_code=403, detail="Forbidden")
    user = db.query(DBUser).filter(DBUser.account == account).first()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    user.password_hash = pwd_context.hash(new_password)
    db.commit()
    return {"message": "Password reset", "user_id": user.user_id}

# @app.post("/api/v1/questions", response_model=QuestionResponse)
# async def ask_question(request: QuestionRequest, db: Session = Depends(get_db)):
#     last_question = db.query(DBQuestion).filter(
#         DBQuestion.session_id == request.session_id
#     ).order_by(DBQuestion.created_at.desc()).first()
#
#     if last_question and (datetime.now() - last_question.created_at).total_seconds() < 1:
#         raise HTTPException(
#             status_code=status.HTTP_429_TOO_MANY_REQUESTS,
#             detail="请求过于频繁"
#         )
#
#     db_session = db.query(DBSession).filter(DBSession.session_id == request.session_id).first()
#     if not db_session:
#         db_session = DBSession(session_id=request.session_id)
#         db.add(db_session)
#         db.commit()
#
#     answer_text, references = answer(request.current_question, request.previous_questions)
#
#     db_question = DBQuestion(
#         session_id=request.session_id,
#         question_id=request.question_id,
#         previous_questions=request.previous_questions,
#         current_question=request.current_question,
#         answer=answer_text,
#         references=references,
#         rating=None
#     )
#     db.add(db_question)
#     db.commit()
#
#     return {
#         "session_id": request.session_id,
#         "question_id": request.question_id,
#         "answer": answer_text,
#         "references": references
#     }


@app.get("/api/v1/questions/stream")
async def stream_question(session_id: str, question_id: str, previous_questions: str, current_question: str, language: str = "en",
                          base: str = "lingnan", user_id: int = Query(None)):
    previous_questions_list = json.loads(previous_questions)

    gen_iter, references = await route_stream(current_question, previous_questions_list, language, base)

    async def event_generator():
        print(f"DEBUG: Starting event_generator for session {session_id}")
        full_answer = ""
        try:
            async for token in gen_iter:
                print(f"DEBUG: Received token: {token[:20]}..." if token else "DEBUG: Received empty token")
                if token:  # Ensure token is not empty
                    full_answer += token
                    yield f"data: {json.dumps({'token': token})}\n\n"
        except Exception as e:
            print(f"Error during stream generation: {e}")
            import traceback
            traceback.print_exc()
            yield f"data: {json.dumps({'error': str(e)})}\n\n"
            # Don't return here, try to save partial answer if possible or just log

        print("DEBUG: Stream finished, sending references")
        # 发送引用文献消息，字段名为 references
        yield f"data: {json.dumps({'references': references})}\n\n"

        # Save to DB
        print(f"DEBUG: Saving to DB. Session: {session_id}, User: {user_id}", flush=True)
        try:
            with SessionLocal() as db:
                # 1. Update/Create Session
                db_session = db.query(DBSession).filter(DBSession.session_id == session_id).first()
                if not db_session:
                    # Check history limit (max 10) for this user
                    if user_id:
                        try:
                            current_count = db.query(DBSession).filter(DBSession.user_id == user_id).count()
                            if current_count >= 10:
                                # Delete oldest session(s)
                                num_to_delete = current_count - 9 # e.g., if 10, delete 1 to make room (result 9+1=10)
                                print(f"DEBUG: User {user_id} has {current_count} sessions. Deleting {num_to_delete} oldest.", flush=True)

                                oldest_sessions = db.query(DBSession).filter(DBSession.user_id == user_id)\
                                    .order_by(DBSession.last_activity.asc())\
                                    .limit(num_to_delete).all()

                                for old_sess in oldest_sessions:
                                    # Manually delete related questions first (if cascade not set)
                                    db.query(DBQuestion).filter(DBQuestion.session_id == old_sess.session_id).delete()
                                    db.delete(old_sess)
                                    print(f"DEBUG: Deleted old session {old_sess.session_id}", flush=True)
                        except Exception as e:
                            print(f"Error enforcing history limit: {e}", flush=True)

                    # New session, use current question as title
                    title = current_question[:50] + "..." if len(current_question) > 50 else current_question
                    db_session = DBSession(session_id=session_id, user_id=user_id, title=title)
                    db.add(db_session)
                    print(f"DEBUG: Created new session {session_id} for user {user_id}", flush=True)
                else:
                    # Update last activity
                    db_session.last_activity = func.now()
                    # If user_id was missing (guest started, then logged in? unlikely flow but safe to set)
                    if user_id and not db_session.user_id:
                        db_session.user_id = user_id
                        print(f"DEBUG: Associated session {session_id} with user {user_id}", flush=True)

                # Commit session changes FIRST to satisfy Foreign Key constraints
                db.commit()

                # 2. Save Question
                db_question = DBQuestion(
                    session_id=session_id,
                    question_id=question_id,
                    previous_questions=json.loads(previous_questions), # Store as JSON
                    current_question=current_question,
                    answer=full_answer,
                    references=references,
                    rating=None
                )
                db.add(db_question)
                db.commit()
                print(f"DEBUG: DB save successful. Question saved with ID: {db_question.question_id}", flush=True)
        except Exception as e:
            print(f"Error saving to DB: {e}", flush=True)
            import traceback
            traceback.print_exc()

        yield "data: [DONE]\n\n"

    return StreamingResponse(event_generator(), media_type="text/event-stream")


@app.get("/api/v1/files/list")
async def list_files(
        base: str = Query("lingnan"),
        db: Session = Depends(get_db)
):
    # 只查询指定 base 下的文件
    files = (
        db.query(DBFile)
        .filter(DBFile.base == base)
        .all()
    )

    return {
        "files": [
            {
                "file_name": file.file_name,
                "file_description": file.file_description,
                "file_path": file.file_path,
                "file_size": file.file_size,
                "uploaded_at": file.uploaded_at,
                "base": file.base
            }
            for file in files
        ]
    }


@app.post("/api/v1/files")
async def upload_file(
        base: str = Form(...),
        file: UploadFile = File(...),
        db: Session = Depends(get_db)
):
    content = await file.read()
    if not content:
        raise HTTPException(status_code=400, detail="Empty file")

    size_kb = len(content) / 1024
    file_size = f"{size_kb:.1f}KB" if size_kb < 1024 else f"{size_kb / 1024:.1f}MB"

    # 文件保存到 policies 目录
    policies_dir = locate_path("knowledge_base", base, "policies")
    os.makedirs(policies_dir, exist_ok=True)
    pieces_dir = locate_path("knowledge_base", base, "pieces")
    os.makedirs(pieces_dir, exist_ok=True)

    policy_path = policy_file(base=base, filename=file.filename)
    pieces_path = piece_dir(base=base)
    with open(policy_path, "wb") as f:
        f.write(content)

    file_description = await split(policy_path, pieces_path)
    try:
        asyncio.create_task(ingest_file(base, policy_path))
    except Exception:
        pass

    # 先看看同名文件是否已存在
    existing = (
        db.query(DBFile)
        .filter(DBFile.base == base,
                DBFile.file_name == file.filename)
        .first()
    )
    if existing:
        existing.file_size = file_size
        existing.file_description = file_description
        existing.uploaded_at = datetime.now(timezone.utc)
        db.commit()
        db.refresh(existing)
        return {
            "base": existing.base,
            "file_name": existing.file_name,
            "file_description": existing.file_description,
            "file_path": existing.file_path,
            "uploaded_at": existing.uploaded_at,
            "file_size": existing.file_size,
            "message": "Existing file overwritten"
        }

    # 不存在则新建，显式传入 base，让 SQL 默认值生效也会回填
    new_file = DBFile(
        base=base,
        file_name=file.filename,
        file_description=file_description,
        file_path=policy_path,
        file_size=file_size
    )
    db.add(new_file)
    db.commit()
    db.refresh(new_file)

    return {
        "base": new_file.base,
        "file_name": new_file.file_name,
        "file_description": new_file.file_description,
        "file_path": new_file.file_path,
        "uploaded_at": new_file.uploaded_at,
        "file_size": new_file.file_size,
        "message": "File uploaded"
    }


@app.get("/api/v1/files/preview")
async def preview_file(
        file_name: str = Query(...),
        base: str = Query(...)
):
    file_path = policy_file(base=base, filename=unquote(file_name))
    if not os.path.exists(file_path):
        raise HTTPException(status_code=404, detail="File not found")
    return FileResponse(file_path)


@app.delete("/api/v1/files")
async def delete_file(
        base: str = Query(...),
        file_name: str = Query(...),
        db: Session = Depends(get_db)
):
    # 查找数据库记录
    existing = (
        db.query(DBFile)
        .filter(DBFile.base == base, DBFile.file_name == file_name)
        .first()
    )

    if not existing:
        raise HTTPException(status_code=404, detail="File not found in database")

    # 构造文件路径
    policy_path = policy_file(base=base, filename=file_name)

    deleted_path = os.path.basename(policy_path)
    file_base, _ = os.path.splitext(deleted_path)
    output_format = "txt"
    pieces_path_1 = os.path.join(piece_dir(base=base), f"{file_base}_segmented.{output_format}")
    deleted_piece_path = policy_path.replace("policies", "pieces")
    pieces_path_2 = os.path.join(piece_dir(base=base), f"{deleted_piece_path}.{output_format}")

    # 删除 policy 文件
    if os.path.exists(policy_path):
        os.remove(policy_path)

    # 删除 pieces 文件
    if os.path.exists(pieces_path_1):
        os.remove(pieces_path_1)
    if os.path.exists(pieces_path_2):
        os.remove(pieces_path_2)
    # 删除数据库记录
    db.delete(existing)
    db.commit()

    return {
        "base": base,
        "file_name": file_name,
        "message": "File and related data deleted successfully"
    }


@app.post("/api/v1/feedback", response_model=FeedbackResponse)
async def submit_feedback(request: FeedbackRequest, db: Session = Depends(get_db)):
    question = db.query(DBQuestion).filter(
        DBQuestion.session_id == request.session_id,
        DBQuestion.question_id == request.question_id
    ).first()

    if not question:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="问题不存在"
        )

    if question.rating is not None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该问题已经评分过"
        )

    question.rating = request.rating
    db.commit()

    return {
        "session_id": request.session_id,
        "question_id": request.question_id
    }


@app.get("/api/v1/users/{user_id}/sessions")
async def get_user_sessions(user_id: int, limit: int = 10, db: Session = Depends(get_db)):
    sessions = db.query(DBSession).filter(DBSession.user_id == user_id)\
        .order_by(DBSession.last_activity.desc())\
        .limit(limit)\
        .all()

    return [
        {
            "session_id": s.session_id,
            "title": s.title or "New Chat",
            "created_at": s.created_at,
            "last_activity": s.last_activity
        }
        for s in sessions
    ]

@app.get("/api/v1/sessions/{session_id}/messages")
async def get_session_messages(session_id: str, db: Session = Depends(get_db)):
    questions = db.query(DBQuestion).filter(DBQuestion.session_id == session_id)\
        .order_by(DBQuestion.created_at.asc())\
        .all()

    messages = []
    for q in questions:
        # Add User Question
        messages.append({
            "role": "user",
            "content": q.current_question,
            "id": q.question_id + "_u"
        })
        # Add Assistant Answer
        messages.append({
            "role": "assistant",
            "content": q.answer,
            "references": q.references,
            "id": q.question_id + "_a",
            "rating": q.rating
        })

    return messages


@app.delete("/api/v1/sessions/{session_id}")
async def delete_session(session_id: str, user_id: int = Query(...), db: Session = Depends(get_db)):
    # Verify session exists and belongs to user
    session = db.query(DBSession).filter(
        DBSession.session_id == session_id,
        DBSession.user_id == user_id
    ).first()

    if not session:
        raise HTTPException(status_code=404, detail="Session not found or access denied")

    try:
        # Delete related questions first
        db.query(DBQuestion).filter(DBQuestion.session_id == session_id).delete()

        # Delete session
        db.delete(session)
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(status_code=500, detail=f"Failed to delete session: {str(e)}")

    return {"message": "Session deleted successfully"}


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
